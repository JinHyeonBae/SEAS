
# 개발 환경

## 1. Stacks

### Backend Application

- Java : openjdk-17
- Spring boot : 3.2.2
    - tomcat : 10.1.18, 내장 톰캣
    - gradle : 8.5
    - Spring security : 6.2.1
- docker : 24.0.5
- MySQL : 8.3
- flyway : 9.22.3
- IntelliJ : 2021.2.4

### Frontend Application

- vue : 3.3.11
- vuetify : 5.0.10
- pinia : 2.1.7
- d3 : 7.8.5
- sass : 1.70.0
- chart.js : 4.4.1
- gsap : 3.12.5

## 2. Build & Distribute

- Jenkins : 2.441
- nginx : 1.18.0
- docker : 24.0.5

## 3. 프로그램 실행

### 백엔드 실행 방법

1. docker 폴더(S10P12A609\docker)로 이동
2. 아래의 명령어 실행

```java
docker-compose up -d
```

1. seas-be 폴더 (S10P12A609\seas-be)로 이동
2. 아래의 명령어로 실행

```java
./gradlew bootrun
```

### 프론트엔드 실행 방법

1. seas-fe로 이동 후 vscode 실행
2. bash에서 아래의 명령어 실행

```bash
npm i
```

- 위 명령어로 인해 package.json에 있는 라이브러리를 그대로 받음
1. bash에 아래의 명령어 실행

```bash
npm run dev 
```

- 위 명령어로 localhost로 사이트 실행

## 4. 인프라 환경 설정하기

### EC2에서 docker 설치

```java
sudo apt-get install docker
```

### EC2에서 Jenkins docker build & run

```java
docker pull jenkins
sudo docker exec -p 9090:8080 -v /var/run/docker.sock:/var/run/docker.sock --name jenkins <jenkins_image_name>
```

### Jenkins 접속 방법

```java
jenkins 실행 후 콘솔에서 나오는 임시 비밀번호를 입력, 이후 젠킨스 유저 정보를 설정한 후 젠킨스를 설정할 수 있다.
```

## 4. Jenkins 플러그인 설치 및 파이프라인 작성

### 플러그인 설치


- Jenkins 관리 → Plugin에서 설치 가능
- Plugin 설정은 Jenkins 관리 → Tools에서 설정 가능

<aside>
💡 Tools에서 설정한 plugin의 ID의 경우 추후 파이프라인 스크립트에서 사용하게 된다.
아래의 코드를 참고

</aside>

```java
pipeline{
    agent any
    
    tools {
				// plugin으로 node를 설치하고, tools에서 id를 jenkins-nodejs로 설정
        nodejs 'jenkins-nodejs'
    }    
}
```

### 파이프라인 스크립트

- Jenkins 새로운 ITEM 작성 → 파이프라인 (free Project도 무방) 을 생성할 수 있음

### 프론트(Vue) 파이프라인

```java
pipeline{
    agent any
    
    tools {
        nodejs 'jenkins-nodejs'
        dockerTool 'jenkins-docker'
    }
    
    stages{
        stage('git clone-FE'){
			steps{
				git branch: 'frontend',
				credentialsId : '4d40fefc-0c8d-4a17-86da-da3f0b7acb43',
				url : 'https://lab.ssafy.com/s10-webmobile2-sub2/S10P12A609.git'
			}
		}
		stage('FE-build'){
			steps{
				dir("./docker"){
					sh "docker build -t seas-vue -f ./dockerfile/vue.dockerfile ../"
				}
			}
		}
		stage('FE-docker'){
			steps{
			    sh "docker rm -f seas-vue"
				sh "docker run --name seas-vue -p 5173:80 -d seas-vue"
			}
		}
    }
    
}
```

### 백엔드(Spring boot) 파이프라인

```java
pipeline{
    agent any
    
    tools {
        // Jenkins에서 등록한 Node.js 도구의 이름을 사용하여 자동으로 설치
        gradle 'jenkins-gradle'
        dockerTool 'jenkins-docker'
    }
    
    stages{
        stage('git clone-BE'){
			steps{
				git branch: 'backend',
				credentialsId : '4d40fefc-0c8d-4a17-86da-da3f0b7acb43',
				url : 'https://lab.ssafy.com/s10-webmobile2-sub2/S10P12A609'
			}
		}
        stage('BE-SPRING-CONFIG'){
            steps{
                dir('./'){
                    withCredentials([file(credentialsId: 'seas-config', variable: 'config')]) {
                        sh 'mv ${config} /var/jenkins_home/workspace/seas-back/seas-be/src/main/resources'
                    }
                }
            }
        }
		stage('BE-spring-boot-clean'){
			steps{
                dir("./seas-be"){
				    sh "chmod +x gradlew"
				    sh "./gradlew clean"
				    
				}
			}
		}
		stage('BE-spring-boot-build'){
			steps{
                dir("./seas-be"){
				    
				    sh "./gradlew build -x test --stacktrace"
				}
			}
		}
		stage('BE-docker-image-build'){
			steps{
			    dir("./docker"){
			        sh 'pwd'
                    sh "docker build -t seas-spring -f ./dockerfile/spring.dockerfile ../"
			    }
			}
		}
		stage('BE-docker-container-prune'){
			steps{
			    sh "docker container prune"
			}
		}
		stage('BE-spring-container'){
			steps{
			    dir("."){
			        script{
    			        
            			def containerName = 'seas-spring'
    
                        // 도커 컨테이너 상태 확인 명령어
                        def containerStatus = sh(script: "docker container inspect -f '{{.State.Running}}' $containerName", returnStatus: true)
                        echo "$containerStatus"
                        
                        if (containerStatus == 0) {
                            echo "도커 컨테이너 $containerName 가 실행 중입니다."
                            
                            sh "docker rm -f seas-spring"
                        } 
                        
                        echo "도커 컨테이너 $containerName 가 실행되고 있지 않습니다."
                        sh "docker run --name seas-spring --hostname seas-spring --net backend -p 2890:8080 -d seas-spring"
                    
    			    }
			    }
			}
		}
    }
}
```

### DB(MySQL) 파이프라인

```java
pipeline{
    agent any
    
    tools {
        // Jenkins에서 등록한 Node.js 도구의 이름을 사용하여 자동으로 설치
        gradle 'jenkins-gradle'
        dockerTool 'jenkins-docker'
    }
    
    stages{
        stage('git clone-BE'){
			steps{
				git branch: 'backend',
				credentialsId : '4d40fefc-0c8d-4a17-86da-da3f0b7acb43',
				url : 'https://lab.ssafy.com/s10-webmobile2-sub2/S10P12A609'
			}
		}
        stage('BE-SPRING-CONFIG'){
            steps{
                dir('./'){
                    withCredentials([file(credentialsId: 'seas-config', variable: 'config')]) {
                        sh 'mv ${config} /var/jenkins_home/workspace/seas-back/seas-be/src/main/resources'
                    }
                }
            }
        }
		stage('BE-spring-boot-clean'){
			steps{
                dir("./seas-be"){
				    sh "chmod +x gradlew"
				    sh "./gradlew clean"
				    
				}
			}
		}
		stage('BE-spring-boot-build'){
			steps{
            dir("./seas-be"){
				    
				    sh "./gradlew build -x test --stacktrace"
				}
			}
		}
		stage('BE-docker-image-build'){
			steps{
			    dir("./docker"){
			        sh 'pwd'
                    sh "docker build -t seas-spring -f ./dockerfile/spring.dockerfile ../"
			    }
			}
		}
		stage('BE-docker-container-prune'){
			steps{
			    sh "docker container prune"
			}
		}
		stage('BE-spring-container'){
			steps{
			    dir("."){
			        script{ 			        
            			def containerName = 'seas-spring'
   
                  // 도커 컨테이너 상태 확인 명령어
                  def containerStatus = sh(script: "docker container inspect -f '{{.State.Running}}' $containerName", returnStatus: true)
                  echo "$containerStatus"
                  
                  if (containerStatus == 0) {
                      echo "도커 컨테이너 $containerName 가 실행 중입니다."
                      
                      sh "docker rm -f seas-spring"
                  } 
                  
                  echo "도커 컨테이너 $containerName 가 실행되고 있지 않습니다."
                  sh "docker run --name seas-spring --hostname seas-spring --net backend -p 2890:8080 -d seas-spring"
              
    			    }
			    }
			}
		}
    }
}
```

### Redis 파이프라인

```java
pipeline{
    agent any
    
    tools {
        // Jenkins에서 등록한 Node.js 도구의 이름을 사용하여 자동으로 설치
        gradle 'jenkins-gradle'
        dockerTool 'jenkins-docker'
    }
    
    stages{
	    stage('git clone-BE'){
				steps{
					git branch: 'backend',
					credentialsId : '4d40fefc-0c8d-4a17-86da-da3f0b7acb43',
					url : 'https://lab.ssafy.com/s10-webmobile2-sub2/S10P12A609'
				}
			}
			stage('BE-docker-network'){
			    steps{ 
			        sh "docker network create backend --gateway 172.18.0.1 || true"
			    }
			}
			stage('BE-redis-image-build'){
				steps{
				    dir("./docker"){
				        sh 'pwd'
	                    sh "docker build -t seas-redis -f ./dockerfile/redis.dockerfile ../"
				    }
				}
			}
			stage('BE-docker-container-prune'){
				steps{
				    sh "docker container prune"
				}
			}
			stage('BE-redis-container'){
				steps{
				    dir("."){
				        script{
	            			def containerName = 'seas-redis'
	
	                  // 도커 컨테이너 상태 확인 명령어
	                  def containerStatus = sh(script: "docker container inspect -f '{{.State.Running}}' $containerName", returnStatus: true)
	                  echo "$containerStatus"
	                  
	                  if (containerStatus == 0) {
	                      echo "도커 컨테이너 $containerName 가 실행 중입니다."
	                      sh "docker rm -f seas-mysql"
	                  }
	                  
	                  echo "도커 컨테이너 $containerName 가 실행되고 있지 않습니다."
	                  sh "docker run --name seas-redis -p 6379:6379 --net backend -d seas-redis"
	    			    }
				    }
		    }
    }
}
```

<aside>
💡 도커에서의 컨테이너끼리 통신하기 위해서는 같은 네트워크에 소속되어 있어야 하므로,
백엔드 컨테이너(Spring boot, MySQL, Redis)의 경우 도커 내부에서 ‘backend’ network를
생성하여 묶어준다.

해당 컨테이너들은 컨테이너 이름(docker run 시 —name으로 명명한 이름)으로 통신한다.

</aside>

## 환경 변수 파일

### Backend Infra

```java
infra package

docker
|
|-- dockerfile
|		-- spring, vue, redis, mysql dockerfile 존재
|-- nginx
|		-- nginx.conf 파일 존재, vue 도커 파일에서 사용됨
|
|-- .env 
|-- docker-compose.yml

```

- .env
    - DB 정보 입력

```java
MYSQL_ROOT_PASSWORD=<ROOT 비밀번호 설정>
MYSQL_USER=<DB 유저 이름 설정>
MYSQL_PASSWORD=<DB 유저 비밀번호 설정>
```

- init.sql
    - DB 실행 시 가장 먼저 실행되는 sql 파일

```java
DROP DATABASE IF EXISTS <DB 이름>;
CREATE DATABASE <DB 이름>;
```

- docker-compose.yml
    - 여러 컨테이너를 한 번에 올리기 위해 사용하는 파일
    - redis, mysql이 해당 파일에 기술되어 있음

```java
services:
  seas-redis:
    image: redis
    ports:
      - 6379:6379
    build:
      context: ../
    networks:
      - backend

  seas-mysql:
    build:
      context: ../
      dockerfile: "./docker/dockerfile/mysql.dockerfile"
    env_file: ".env"
    ports:
      - 3306:3306
    networks:
      - backend

networks:
  backend:
    external: true
```

### backend application

- /src/main/resources에 모두 위치
- application.yml
    - 어플리케이션 실행 정보를 담는 파일

```java
spring:
  profiles:
    active: prod
  datasource:
    driver-class-name: <DB driver>
    url: jdbc:mysql://${DB_HOST}:${DB_PORT}/${DB_NAME}?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8&useSSL=false&allowPublicKeyRetrieval=true
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
  jpa:
    hibernate:
      ddl-auto: none
    show-sql: true
    properties:
      hibernate:
        format_sql: true
        show_sql: true

  flyway:
    enabled: true

  redis:
    data:
      host: <레디스 host>
      port: 6379

springdoc:

  swagger-ui:
    # config-url: /v3/api-docs/swagger-config
    path: /swagger
    url: /v3/api-docs
    operations-sorter: method
  api-docs:
    enabled: true
    path: /v3/api-docs

server:
  # forward-headers-strategy: framework
  port: 8080
  servlet:
    context-path: /api

logging:
  level:
    root: INFO
  discord:
    webhook-url: ${DISCORD_WEBHOOK_URL}
  config: classpath:logback-spring.xml

secretKeyPlain: ${KEY}
```

- seas-config.yml
    - application 환경변수의 실제 값을 담고 있는 파일

```java
DB_DRIVER: <사용하는 DB Driver>
DB_HOST: <DB 호스트>
DB_PORT: <DB 포트>
DB_NAME: <DB 데이터베이스>
DB_USERNAME: <접속 유저>
DB_PASSWORD: <유저 비밀번호>
// token Key
KEY: <Token Key>
// 디스코드 로깅용 주소
DISCORD_WEBHOOK_URL: <discord 로깅용 주소>
```

- logback-spring.xml
    - 서버 로깅용으로 설정해놓은 파일입니다.

```java
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] [traceId=%X{traceId}] %-5level %logger{36}.%M - %msg%n
            </pattern>
        </encoder>
    </appender>
    <springProfile name="(dev | prod)">
        <root level="info">
            <appender-ref ref="CONSOLE"/>
        </root>
    </springProfile>
</configuration>
```

## 외부 서비스 정보

### S3(프론트 이미지 저장)

- https://aws.amazon.com/ko/s3/?nc2=type_a

### CloudFront(캐싱을 위한 엣지 서버)

- https://aws.amazon.com/ko/cloudfront/?nc2=type_a

## DB 덤프 파일

## 시연 시나리오
